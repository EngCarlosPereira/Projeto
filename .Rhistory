plot.ts(Log_Base_Dados)
Log_Base_Dados <- log(Stemp_Base_Dados)
plot.ts(Log_Base_Dados)
Stemp_Base_Dados
lag(Stemp_Base_Dados, -1)
lag(Stemp_Base_Dados, -2)
Stemp_Base_Dados
lag(Base_Dados, -1)
lag(Base_Dados, -2)
tsData <- ts(Stemp_Base_Dados)
tsData
LaggedTs <- lag(tsData,3)
myDf <- as.data.frame(tsData)
myDf
myDf <- slide(myDf, "x",NewVar = "xLag1", slideBy = -1 )
myDf <- slide(myDf, "x",NewVar = "xLead1", slideBy = 1 )
head(myDf)
hist(Stemp_Base_Dados)
# 2.3 Autocorrelação
teste = acf(Stemp_Base_Dados, lag.max = 20 )
teste
pacf(Stemp_Base_Dados, 12)
# 2.3 Autocorrelação
teste = acf(Stemp_Base_Dados, lag.max = 20 )
teste
pacf(Stemp_Base_Dados, 12)
# 2.3 Autocorrelação
Stemp_Base_Dados_acf = acf(Stemp_Base_Dados, lag.max = 20 )
Stemp_Base_Dados_pacf(Stemp_Base_Dados, 12)
# 2.3 Autocorrelação
Stemp_Base_Dados_acf = acf(Stemp_Base_Dados, lag.max = 20 )
Stemp_Base_Dados_pacf(Stemp_Base_Dados, 12)
pacf(Stemp_Base_Dados, 12)
pacf=pacf(Stemp_Base_Dados, 12)
# 2.3 Autocorrelação
Stemp_Base_Dados_acf = acf(Stemp_Base_Dados, lag.max = 20 )
teste
Stemp_Base_Dados_pacf=pacf(Stemp_Base_Dados, 12)
nsdiffs(Stemp_Base_Dados)  # número para diferenciação sazonal necessário. Retornou o valor Zerado
plotForecastErrors <- function(forecastErrors)
{
forecastErrorsSd <- sd(x = forecastErrors,
na.rm = TRUE)
forecastErrorsMin <- min(forecastErrors,
na.rm = TRUE) - forecastErrorsSd * 5
forecastErrorsMax <- max(forecastErrors,
na.rm = TRUE) + forecastErrorsSd * 3
forecastErrorsNorm <- rnorm(n = 10000,
mean = 0,
sd = forecastErrorsSd)
binMin <- min(forecastErrorsMin, forecastErrorsNorm)
binMax <- max(forecastErrorsMax, forecastErrorsNorm)
binBreaks <- IQR(x = forecastErrors,
na.rm = TRUE) / 4
bins <- seq(from = binMin,
to = binMax,
by = binBreaks)
hist(x = forecastErrors,
col = "#DCE319FF",
freq = FALSE,
breaks = bins)
with(data = hist(x = forecastErrorsNorm,
plot = FALSE,
breaks = bins),
expr = lines(x = mids,
y = density,
col = "#440154FF",
lwd = 3))
}
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts2$forecast$xhat$residuals)
# Passo 1
autoplot(Stemp_Base_Dados)
dec <- decompose(Stemp_Base_Dados)
autoplot(dec)
# Passo 2
nsdiffs(Stemp_Base_Dados)  # número para diferenciação sazonal necessário. Retornou o valor 1
Stemp_Base_Dados_diff <- diff(Stemp_Base_Dados, lag=frequency(Stemp_Base_Dados), differences=1)  # diferenciação sazonal
plot(Stemp_Base_Dados_diff, main = "Diferença Sazonal")
Stemp_Base_Dados_diff # Não usarei essa base com difernciação de número 1, irei usar direto no ARIMA
# Passo 3
pacf(Stemp_Base_Dados_diff)
acf(Stemp_Base_Dados_diff)
nsdiffs(Stemp_Base_Dados)
ndiffs(Stemp_Base_Dados)
# Passo 4
mod.arima <- Arima(Stemp_Base_Dados, order = c(1, 1,1), seasonal = c(1, 1, 1))
# usamos o lambda devido a transformação de BoxCox
summary(mod.arima)
autoplot(Stemp_Base_Dados) + autolayer(mod.arima$fitted)
# Passo 6
prev.arima <- forecast(mod.arima, h = 12)
autoplot(prev.arima)
checkresiduals(mod.arima)
### Aplicando Auto ARIMA
auto.arima(Stemp_Base_Dados, trace = TRUE, approximation = FALSE)
mod.aa <- Arima(Stemp_Base_Dados, order = c(2, 0, 0), seasonal = c(2, 1, 0), include.drift = FALSE)
checkresiduals(mod.aa)
# Passo 4
prev.aa <- forecast(mod.aa, h = 12)
autoplot(prev.aa)
autoplot(Stemp_Base_Dados) + autolayer(prev.aa$fitted)
# Passo 1
autoplot(Stemp_Base_Dados)
plotForecastErrors <- function(forecastErrors)
{
forecastErrorsSd <- sd(x = forecastErrors,
na.rm = TRUE)
forecastErrorsMin <- min(forecastErrors,
na.rm = TRUE) - forecastErrorsSd * 5
forecastErrorsMax <- max(forecastErrors,
na.rm = TRUE) + forecastErrorsSd * 3
forecastErrorsNorm <- rnorm(n = 10000,
mean = 0,
sd = forecastErrorsSd)
binMin <- min(forecastErrorsMin, forecastErrorsNorm)
binMax <- max(forecastErrorsMax, forecastErrorsNorm)
binBreaks <- IQR(x = forecastErrors,
na.rm = TRUE) / 4
bins <- seq(from = binMin,
to = binMax,
by = binBreaks)
hist(x = forecastErrors,
col = "#DCE319FF",
freq = FALSE,
breaks = bins)
with(data = hist(x = forecastErrorsNorm,
plot = FALSE,
breaks = bins),
expr = lines(x = mids,
y = density,
col = "#440154FF",
lwd = 3))
}
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts2$forecast$xhat$residuals)
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts$forecast$xhat$residuals)
rainseriesforecasts <- HoltWinters(Stemp_Base_Dados, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts$fitted)
plot(rainseriesforecasts$fitted)
rainseriesforecasts$SSE
HoltWinters(rainseriesforecasts$fitted, beta=FALSE, gamma=FALSE, l.start=5.86 ) # utilizando o primeiro valor previsto
rainseriesforecasts2  <- forecast(rainseriesforecasts$fitted, h=24)
rainseriesforecasts2
plot(rainseriesforecasts2)
coefficients(rainseriesforecasts2$forecast$xhat$model$residuals )
checkresiduals(rainseriesforecasts2$forecast$xhat$model$residuals)
rainseriesforecasts2$forecast$xhat$model$residuals
plot.ts(rainseriesforecasts2$forecast$xhat$model$residuals)
View (rainseriesforecasts2)
acf(rainseriesforecasts2$forecast$xhat$residuals, lag.max = 20, na.action = na.pass)
Box.test(rainseriesforecasts2$forecast$xhat$residuals, lag=20, type="Ljung-Box")
plotForecastErrors <- function(forecastErrors)
{
forecastErrorsSd <- sd(x = forecastErrors,
na.rm = TRUE)
forecastErrorsMin <- min(forecastErrors,
na.rm = TRUE) - forecastErrorsSd * 5
forecastErrorsMax <- max(forecastErrors,
na.rm = TRUE) + forecastErrorsSd * 3
forecastErrorsNorm <- rnorm(n = 10000,
mean = 0,
sd = forecastErrorsSd)
binMin <- min(forecastErrorsMin, forecastErrorsNorm)
binMax <- max(forecastErrorsMax, forecastErrorsNorm)
binBreaks <- IQR(x = forecastErrors,
na.rm = TRUE) / 4
bins <- seq(from = binMin,
to = binMax,
by = binBreaks)
hist(x = forecastErrors,
col = "#DCE319FF",
freq = FALSE,
breaks = bins)
with(data = hist(x = forecastErrorsNorm,
plot = FALSE,
breaks = bins),
expr = lines(x = mids,
y = density,
col = "#440154FF",
lwd = 3))
}
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts2$forecast$xhat$residuals)
# Passo 1
autoplot(Stemp_Base_Dados)
dec <- decompose(Stemp_Base_Dados)
autoplot(dec)
# Passo 2
nsdiffs(Stemp_Base_Dados)  # número para diferenciação sazonal necessário. Retornou o valor 1
Stemp_Base_Dados_diff <- diff(Stemp_Base_Dados, lag=frequency(Stemp_Base_Dados), differences=1)  # diferenciação sazonal
plot(Stemp_Base_Dados_diff, main = "Diferença Sazonal")
Stemp_Base_Dados_diff # Não usarei essa base com difernciação de número 1, irei usar direto no ARIMA
rainseriesforecasts <- HoltWinters(Stemp_Base_Dados, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts$fitted)
rainseriesforecasts$SSE
HoltWinters(rainseriesforecasts$fitted, beta=FALSE, gamma=FALSE, l.start=5.86 ) # utilizando o primeiro valor previsto
rainseriesforecasts2  <- forecast(rainseriesforecasts$fitted, h=24)
rainseriesforecasts2
plot(rainseriesforecasts2)
coefficients(rainseriesforecasts2$forecast$xhat$model$residuals )
checkresiduals(rainseriesforecasts2$forecast$xhat$model$residuals)
rainseriesforecasts2$forecast$xhat$model$residuals
plot.ts(rainseriesforecasts2$forecast$xhat$model$residuals)
View (rainseriesforecasts2)
acf(rainseriesforecasts2$forecast$xhat$residuals, lag.max = 20, na.action = na.pass)
Box.test(rainseriesforecasts2$forecast$xhat$residuals, lag=20, type="Ljung-Box")
plotForecastErrors <- function(forecastErrors)
{
forecastErrorsSd <- sd(x = forecastErrors,
na.rm = TRUE)
forecastErrorsMin <- min(forecastErrors,
na.rm = TRUE) - forecastErrorsSd * 5
forecastErrorsMax <- max(forecastErrors,
na.rm = TRUE) + forecastErrorsSd * 3
forecastErrorsNorm <- rnorm(n = 10000,
mean = 0,
sd = forecastErrorsSd)
binMin <- min(forecastErrorsMin, forecastErrorsNorm)
binMax <- max(forecastErrorsMax, forecastErrorsNorm)
binBreaks <- IQR(x = forecastErrors,
na.rm = TRUE) / 4
bins <- seq(from = binMin,
to = binMax,
by = binBreaks)
hist(x = forecastErrors,
col = "#DCE319FF",
freq = FALSE,
breaks = bins)
with(data = hist(x = forecastErrorsNorm,
plot = FALSE,
breaks = bins),
expr = lines(x = mids,
y = density,
col = "#440154FF",
lwd = 3))
}
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts2$forecast$xhat$residuals)
# Passo 3
pacf(Stemp_Base_Dados_diff)
acf(Stemp_Base_Dados_diff)
nsdiffs(Stemp_Base_Dados)
ndiffs(Stemp_Base_Dados)
# Passo 4
mod.arima <- Arima(Stemp_Base_Dados, order = c(1, 1,1), seasonal = c(1, 1, 1))
# usamos o lambda devido a transformação de BoxCox
summary(mod.arima)
autoplot(Stemp_Base_Dados) + autolayer(mod.arima$fitted)
# Passo 6
prev.arima <- forecast(mod.arima, h = 12)
autoplot(prev.arima)
checkresiduals(mod.arima)
### Aplicando Auto ARIMA
auto.arima(Stemp_Base_Dados, trace = TRUE, approximation = FALSE)
mod.aa <- Arima(Stemp_Base_Dados, order = c(2, 0, 0), seasonal = c(2, 1, 0), include.drift = FALSE)
checkresiduals(mod.aa)
# Passo 4
prev.aa <- forecast(mod.aa, h = 12)
autoplot(prev.aa)
autoplot(Stemp_Base_Dados) + autolayer(prev.aa$fitted)
# Passo 4
prev.aa <- forecast(mod.aa, h = 12)
autoplot(prev.aa)
teste(prev.aa)
teste <-(prev.aa)
teste
# Setando valores máximos de plotagem
options(max.print = 999999)
### Aplicando Auto ARIMA
auto.arima(Stemp_Base_Dados, trace = TRUE, approximation = FALSE)
mod.aa <- Arima(Stemp_Base_Dados, order = c(2, 0, 0), seasonal = c(2, 1, 0), include.drift = FALSE)
checkresiduals(mod.aa)
# Passo 6
prev.aa <- forecast(mod.aa, h = 12)
autoplot(prev.aa)
teste <-(prev.aa)
teste
autoplot(Stemp_Base_Dados) + autolayer(prev.aa$fitted)
# Título do Trabalho: Modelo para previsão de dados de Irradiação solar parageração de energia com base em séries temporais
# Autor: Carlos Pereira de Jesus
# Orientador: Mateus Modesto
# Curso: Data Science e Analytics – 2022
# Setando valores máximos de plotagem
options(max.print = 999999)
# 1.1: Carregando base de dados coletada do Site da NASA com os valores da Irradiação entre os anos de 1984 e 2021
Base_Dados = read.csv(file = "C:\\Pessoal\\Pós\\TCC\\Projeto\\Base_Irrad_1984_2022.csv")
Stemp_Base_Dados <- ts(Base_Dados, start = c(1984,1),  end = c(2021,12),frequency =  12)
Stemp_Base_Dados
plot.ts(Stemp_Base_Dados, lwd=0.5, col = "black",
main = "Série Temportal - Caucáia-CE - 1984 a 2021",
xlab = "Anos", ylab = "Irradiação  (kW-hr/m^2/day)")
axis(2, at=seq(from= 1984, to=2021, by=1))
Log_Base_Dados <- log(Stemp_Base_Dados)
plot.ts(Log_Base_Dados)
dec <- decompose(Stemp_Base_Dados)
autoplot(dec)
Stemp_Base_Dados
lag(Base_Dados, -1)
lag(Base_Dados, -2)
tsData <- ts(Stemp_Base_Dados)
tsData
LaggedTs <- lag(tsData,3)
myDf <- as.data.frame(tsData)
myDf
myDf <- slide(myDf, "x",NewVar = "xLag1", slideBy = -1 )
myDf <- slide(myDf, "x",NewVar = "xLead1", slideBy = 1 )
head(myDf)
hist(Stemp_Base_Dados)
# 2.3 Autocorrelação e Autocorrelação Parcial
Stemp_Base_Dados_acf = acf(Stemp_Base_Dados, lag.max = 20 )
teste
Stemp_Base_Dados_pacf=pacf(Stemp_Base_Dados, 12)
# 2.4 Autocorrelação e Autocorrelação Parcial
nsdiffs(Stemp_Base_Dados)  # número para diferenciação sazonal necessário. Retornou o valor 1
Stemp_Base_Dados_diff <- diff(Stemp_Base_Dados, lag=frequency(Stemp_Base_Dados), differences=1)  # diferenciação sazonal
plot(Stemp_Base_Dados_diff, main = "Diferença Sazonal")
Stemp_Base_Dados_diff
rainseriesforecasts <- HoltWinters(Stemp_Base_Dados, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts$fitted)
rainseriesforecasts$SSE
HoltWinters(rainseriesforecasts$fitted, beta=FALSE, gamma=FALSE, l.start=5.86 ) # utilizando o primeiro valor previsto
rainseriesforecasts2  <- forecast(rainseriesforecasts$fitted, h=24)
rainseriesforecasts2
plot(rainseriesforecasts2)
coefficients(rainseriesforecasts2$forecast$xhat$model$residuals )
checkresiduals(rainseriesforecasts2$forecast$xhat$model$residuals)
rainseriesforecasts2$forecast$xhat$model$residuals
plot.ts(rainseriesforecasts2$forecast$xhat$model$residuals)
View (rainseriesforecasts2)
acf(rainseriesforecasts2$forecast$xhat$residuals, lag.max = 20, na.action = na.pass)
Box.test(rainseriesforecasts2$forecast$xhat$residuals, lag=20, type="Ljung-Box")
plotForecastErrors <- function(forecastErrors)
{
forecastErrorsSd <- sd(x = forecastErrors,
na.rm = TRUE)
forecastErrorsMin <- min(forecastErrors,
na.rm = TRUE) - forecastErrorsSd * 5
forecastErrorsMax <- max(forecastErrors,
na.rm = TRUE) + forecastErrorsSd * 3
forecastErrorsNorm <- rnorm(n = 10000,
mean = 0,
sd = forecastErrorsSd)
binMin <- min(forecastErrorsMin, forecastErrorsNorm)
binMax <- max(forecastErrorsMax, forecastErrorsNorm)
binBreaks <- IQR(x = forecastErrors,
na.rm = TRUE) / 4
bins <- seq(from = binMin,
to = binMax,
by = binBreaks)
hist(x = forecastErrors,
col = "#DCE319FF",
freq = FALSE,
breaks = bins)
with(data = hist(x = forecastErrorsNorm,
plot = FALSE,
breaks = bins),
expr = lines(x = mids,
y = density,
col = "#440154FF",
lwd = 3))
}
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts2$forecast$xhat$residuals)
################################   Passo 3: Usar séries diferenciadas para definir p e q    #################################################
pacf(Stemp_Base_Dados_diff)
acf(Stemp_Base_Dados_diff)
nsdiffs(Stemp_Base_Dados)
ndiffs(Stemp_Base_Dados)
################################   Passo 4: Implementando o Arima nos dados originais    #################################################
mod.arima <- Arima(Stemp_Base_Dados, order = c(1, 1,1), seasonal = c(1, 1, 1))
summary(mod.arima)
autoplot(Stemp_Base_Dados) + autolayer(mod.arima$fitted)
################################   Passo 5: Verificando o Modelo    #################################################
prev.arima <- forecast(mod.arima, h = 12)
autoplot(prev.arima)
checkresiduals(mod.arima)
### Aplicando Auto ARIMA
auto.arima(Stemp_Base_Dados, trace = TRUE, approximation = FALSE)
mod.aa <- Arima(Stemp_Base_Dados, order = c(2, 0, 0), seasonal = c(2, 1, 0), include.drift = FALSE)
checkresiduals(mod.aa)
################################   Passo 6: Previsões do Modelo    #################################################
prev.aa <- forecast(mod.aa, h = 12)
# Título do Trabalho: Modelo para previsão de dados de Irradiação solar parageração de energia com base em séries temporais
# Autor: Carlos Pereira de Jesus
# Orientador: Mateus Modesto
# Curso: Data Science e Analytics – 2022
# Setando valores máximos de plotagem
options(max.print = 999999)
pacotes <- c("dplyr", "datasets","prophet", "forecast","fpp2","tseries","patchwork", "DataCombine", "TTR")
pacotes <- c("dplyr", "datasets","prophet", "forecast","fpp2","tseries","patchwork", "DataCombine", "TTR")
if(sum(as.numeric(!pacotes %in% installed.packages())) != 0){
instalador <- pacotes[!pacotes %in% installed.packages()]
for(i in 1:length(instalador)) {
install.packages(instalador, dependencies = T)
break()}
sapply(pacotes, require, character = T)
} else {
sapply(pacotes, require, character = T)
}
# 1.1: Carregando base de dados coletada do Site da NASA com os valores da Irradiação entre os anos de 1984 e 2021
Base_Dados = read.csv(file = "C:\\Pessoal\\Pós\\TCC\\Projeto\\Base_Irrad_1984_2022.csv")
Stemp_Base_Dados <- ts(Base_Dados, start = c(1984,1),  end = c(2021,12),frequency =  12)
Stemp_Base_Dados
plot.ts(Stemp_Base_Dados, lwd=0.5, col = "black",
main = "Série Temportal - Caucáia-CE - 1984 a 2021",
xlab = "Anos", ylab = "Irradiação  (kW-hr/m^2/day)")
axis(2, at=seq(from= 1984, to=2021, by=1))
Log_Base_Dados <- log(Stemp_Base_Dados)
plot.ts(Log_Base_Dados)
dec <- decompose(Stemp_Base_Dados)
autoplot(dec)
Stemp_Base_Dados
lag(Base_Dados, -1)
lag(Base_Dados, -2)
tsData <- ts(Stemp_Base_Dados)
tsData
LaggedTs <- lag(tsData,3)
myDf <- as.data.frame(tsData)
myDf
myDf <- slide(myDf, "x",NewVar = "xLag1", slideBy = -1 )
myDf <- slide(myDf, "x",NewVar = "xLead1", slideBy = 1 )
head(myDf)
hist(Stemp_Base_Dados)
# 2.3 Autocorrelação e Autocorrelação Parcial
Stemp_Base_Dados_acf = acf(Stemp_Base_Dados, lag.max = 20 )
teste
Stemp_Base_Dados_pacf=pacf(Stemp_Base_Dados, 12)
# 2.4 Autocorrelação e Autocorrelação Parcial
nsdiffs(Stemp_Base_Dados)  # número para diferenciação sazonal necessário. Retornou o valor 1
Stemp_Base_Dados_diff <- diff(Stemp_Base_Dados, lag=frequency(Stemp_Base_Dados), differences=1)  # diferenciação sazonal
plot(Stemp_Base_Dados_diff, main = "Diferença Sazonal")
Stemp_Base_Dados_diff
rainseriesforecasts <- HoltWinters(Stemp_Base_Dados, beta=FALSE, gamma=FALSE)
rainseriesforecasts
rainseriesforecasts$fitted
plot(rainseriesforecasts$fitted)
rainseriesforecasts$SSE
HoltWinters(rainseriesforecasts$fitted, beta=FALSE, gamma=FALSE, l.start=5.86 ) # utilizando o primeiro valor previsto
rainseriesforecasts2  <- forecast(rainseriesforecasts$fitted, h=24)
rainseriesforecasts2
plot(rainseriesforecasts2)
coefficients(rainseriesforecasts2$forecast$xhat$model$residuals )
checkresiduals(rainseriesforecasts2$forecast$xhat$model$residuals)
rainseriesforecasts2$forecast$xhat$model$residuals
plot.ts(rainseriesforecasts2$forecast$xhat$model$residuals)
View (rainseriesforecasts2)
acf(rainseriesforecasts2$forecast$xhat$residuals, lag.max = 20, na.action = na.pass)
Box.test(rainseriesforecasts2$forecast$xhat$residuals, lag=20, type="Ljung-Box")
plotForecastErrors <- function(forecastErrors)
{
forecastErrorsSd <- sd(x = forecastErrors,
na.rm = TRUE)
forecastErrorsMin <- min(forecastErrors,
na.rm = TRUE) - forecastErrorsSd * 5
forecastErrorsMax <- max(forecastErrors,
na.rm = TRUE) + forecastErrorsSd * 3
forecastErrorsNorm <- rnorm(n = 10000,
mean = 0,
sd = forecastErrorsSd)
binMin <- min(forecastErrorsMin, forecastErrorsNorm)
binMax <- max(forecastErrorsMax, forecastErrorsNorm)
binBreaks <- IQR(x = forecastErrors,
na.rm = TRUE) / 4
bins <- seq(from = binMin,
to = binMax,
by = binBreaks)
hist(x = forecastErrors,
col = "#DCE319FF",
freq = FALSE,
breaks = bins)
with(data = hist(x = forecastErrorsNorm,
plot = FALSE,
breaks = bins),
expr = lines(x = mids,
y = density,
col = "#440154FF",
lwd = 3))
}
# plotando o histograma dos erros de previsão
plotForecastErrors(rainseriesforecasts2$forecast$xhat$residuals)
################################   Passo 3: Usar séries diferenciadas para definir p e q    #################################################
pacf(Stemp_Base_Dados_diff)
acf(Stemp_Base_Dados_diff)
nsdiffs(Stemp_Base_Dados)
ndiffs(Stemp_Base_Dados)
################################   Passo 4: Implementando o Arima nos dados originais    #################################################
mod.arima <- Arima(Stemp_Base_Dados, order = c(1, 1,1), seasonal = c(1, 1, 1))
summary(mod.arima)
autoplot(Stemp_Base_Dados) + autolayer(mod.arima$fitted)
################################   Passo 5: Verificando o Modelo    #################################################
prev.arima <- forecast(mod.arima, h = 12)
autoplot(prev.arima)
checkresiduals(mod.arima)
### Aplicando Auto ARIMA
auto.arima(Stemp_Base_Dados, trace = TRUE, approximation = FALSE)
mod.aa <- Arima(Stemp_Base_Dados, order = c(2, 0, 0), seasonal = c(2, 1, 0), include.drift = FALSE)
checkresiduals(mod.aa)
################################   Passo 6: Previsões do Modelo    #################################################
prev.aa <- forecast(mod.aa, h = 12)
################################   Passo 6: Previsões do Modelo    #################################################
prev.aa <- forecast(mod.aa, h = 12)
autoplot(prev.aa)
teste <-(prev.aa)
teste
